//Package and import declarations
import java_cup.runtime.*;




// //User code components (Linking with the lexer)

// parser code {:
//     // Connect this parser to a scanner!
//     scanner s;
//     Parser(scanner s){ this.s=s; }
// :}

// //  define how to connect to the scanner! 
// init with {: s.init(); :};
// scan with {: return s.next_token(); :};

parser code  {: 
  public boolean syntaxErrors = false;
  public void syntax_error(Symbol current_token) {
  	  syntaxErrors = true;
      report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null);
      }
:};



//Symbols (Terminal and non-terminal lists)

terminal SEMI, COLON, LPAREN, RPAREN, COMMA, LCURL, RCURL, LBRACKET, RBRACKET, NOT, COLONCOLON;
terminal CHARACTER, BOOL, DICT, SEQ, NUMBER, TOP, BOOLEAN, RAT, INT, FLOAT, CHAR;
terminal ALIAS, IF, FI, LOOP, POOL, TDEF, BREAK, FDEF, THEN, ELSE, IN;
terminal IDENTIFIER;
terminal PLUS,  MINUS, TIMES, DIV, MOD;
terminal COLONEQ, LT, LTEQ, EQ, NOTEQ;
terminal AND, OR, IMPLY;
terminal RETURN, MAIN, READ, FUNCTION, POW;
terminal QMARK;


///

non terminal statements, body, declaration, expression, declaration_assignment, dictionary_binding, typeDefinition, objectArray;
non terminal alias, parameter, parameterTail, function, returnType, if_statement, if_else_statement, break_statement;
non terminal loop_statement, comparison, equality, boolean_operations, sequence, sequenceTail, operation, concat, concat_tail;
non terminal dictionary, dict_element, seq_element, in, data, sequenceSlicing, data_type, return_, function_call, params;


//Precedence declaration

precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;



//Grammar (context-free)

//number ::= FLOAT | RAT | INT
data ::= NUMBER
	 |
	 CHARACTER
	 |
	 BOOLEAN
	 ;

data_type ::= SEQ 
          | 
          DICT //this might be an issue
          |
          INT
          |
          FLOAT
          |
          RAT
          |
          BOOL
          |
          CHAR
          ;

statements ::= declaration 
		   | 
		   declaration_assignment 
		   | 
		   break_statement
		   ;  ///the body of the functions


body ::= body statements 
	 | 
	 ;


declaration ::= IDENTIFIER COLON data_type |  IDENTIFIER COLON data_type SEMI;

expression ::= data 
		   | 
		   function_call
		   | 
		   operation 
		   | 
		   comparison 
		   | 
		   IDENTIFIER
		   ;       //we should add this to ambiguities that we can assign functions in declarations

declaration_assignment ::= declaration COLONEQ expression; //define data imo the data should be passed from the lexer 

dictionary_binding ::= IDENTIFIER LBRACKET expression RBRACKET COLON COLONEQ expression;

dictionary ::= LCURL dict_element RCURL;
dict_element ::= data_type COLON data_type COMMA dict_element
			 | 
			 ;

sequence ::=  LBRACKET seq_element RBRACKET SEMI;
seq_element ::= data_type COMMA seq_element
			|
			;


typeDefinition ::= TDEF IDENTIFIER LCURL objectArray RCURL SEMI;
objectArray ::= IDENTIFIER COLON data_type COMMA objectArray 
			| 
			IDENTIFIER COLON data_type SEMI
			;


alias ::= ALIAS data_type IDENTIFIER SEMI 
      | 
      ALIAS IDENTIFIER IDENTIFIER SEMI
      ;


parameter ::= data_type IDENTIFIER parameterTail; 

parameterTail ::= COMMA parameter 
			  | 
			  ;


// //function declaration
// //fucntion use

function_call ::= IDENTIFIER LPAREN params RPAREN SEMI;

params ::= expression COMMA params 
       | expression 
       |
       ;

function ::= FDEF IDENTIFIER LPAREN parameter RPAREN LCURL body RCURL returnType SEMI; ////do we need to consider space?

returnType ::= COLON data_type 
		   |
		   ;


if_statement ::= IF LPAREN expression RPAREN THEN body if_else_statement FI;

if_else_statement ::= ELSE body 
				  |
				  ;


break_statement ::= BREAK 
				| 
				BREAK NUMBER
				;   //the ambiguity here is that when break is outside the loop how would we realize

loop_statement ::= LOOP body POOL;

comparison ::= NUMBER LT NUMBER
 		   |
 		   NUMBER LTEQ NUMBER
 		   ;
 		   
equality ::= NUMBER EQ NUMBER
		 | 
		 BOOL EQ BOOL
		 | 
		 NUMBER NOTEQ NUMBER
		 | 
		 BOOL NOTEQ BOOL
		 ;


// //We need to think about this case bool a = 2
boolean_operations ::= NOT expression 
		   		   | 
		   		   expression AND expression
		           | 
		           expression OR expression
		           | 
		           expression IMPLY expression
		           ;



in ::= data_type IN sequence 
   | 
   data_type IN dictionary
   ;

sequenceSlicing ::= IDENTIFIER LBRACKET sequenceTail RBRACKET 
         | 
         data_type IN data_type 
         | 
         data_type COLON data_type
         ;

sequenceTail ::= IDENTIFIER COLON IDENTIFIER 
             | 
             IDENTIFIER COLON 
             | 
             COLON IDENTIFIER
             ;

concat ::= SEQ COLONCOLON SEQ concat_tail 
       | 
       IDENTIFIER COLONCOLON IDENTIFIER concat_tail
       ;

concat_tail  ::= COLONCOLON SEQ concat_tail 
            |  
            COLONCOLON IDENTIFIER concat_tail 
            |
            ;

main ::= MAIN LCURL body RCURL SEMI;

return_ ::= RETURN SEMI
        | 
        RETURN expression SEMI
        ;

//one of the amguities is + coming before negative numbers

operation  ::= operation PLUS operation   
	      |
	      operation MINUS operation   
	      | 
          operation TIMES operation 
	      | 
	      operation DIV operation 
	      | 
          operation MOD operation 
	      | 
          NUMBER                  
	      | 
          MINUS operation             
	      | 
          LPAREN operation RPAREN
          ;     

