//Package and import declarations
import java_cup.runtime.*;




// //User code components (Linking with the lexer)

// parser code {:
//     // Connect this parser to a scanner!
//     scanner s;
//     Parser(scanner s){ this.s=s; }
// :}

// //  define how to connect to the scanner!
// init with {: s.init(); :};
// scan with {: return s.next_token(); :};

parser code  {:
  public boolean syntaxErrors = false;
  public void syntax_error(Symbol current_token) {
  	  syntaxErrors = true;
      report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null);
      }
:};



//Symbols (Terminal and non-terminal lists)

terminal SEMI, COLON, LPAREN, RPAREN, COMMA, LCURL, RCURL, LBRACKET, RBRACKET, NOT, COLONCOLON;
terminal CHARACTER, BOOL, DICT, SEQ, NUMBER, TOP, BOOLEAN, RAT, INT, FLOAT, CHAR;
terminal ALIAS, IF, FI, LOOP, POOL, TDEF, BREAK, FDEF, THEN, ELSE, IN;
terminal IDENTIFIER;
terminal PLUS,  MINUS, TIMES, DIV, MOD;
terminal COLONEQ, LT, GT, LTEQ, EQ, NOTEQ;
terminal AND, OR, IMPLY;
terminal RETURN, MAIN, READ, PRINT, POW;
terminal QMARK, STRING, DOT;


//DEAL WITH PRINT

non terminal statements, statements_, body, declaration, expression, declaration_assignment, dictionary_binding, typeDefinition, objectArray;
non terminal alias, parameter, parameterTail, function, returnType, if_statement, if_else_statement, break_statement;
non terminal loop_statement, comparison, equality, boolean_operations, sequence, sequenceTail, operation, concat, concat_tail;
non terminal dictionary, dict_element, seq_element, in, data, sequenceSlicing, data_type, return_, function_call, params, params_;
non terminal main, initial, dec, arr, seq, assignment, dict, program_block, all_data, identifier, comp;
non terminal idiot;
non terminal print_statement, read_statement, decla, statements__;


//Precedence declaration

precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD, POW;
precedence left NOT, AND, OR, IMPLY;
precedence left EQ, NOTEQ, LTEQ, LT;
precedence left LPAREN, RPAREN;




//Grammar (context-free)

//number ::= FLOAT | RAT | INT

start with initial;

initial ::= program_block main program_block;


program_block ::= statements | ;



function ::= FDEF IDENTIFIER LPAREN parameter RPAREN LCURL statements RCURL returnType SEMI; ////do we need to consider space?

returnType ::= COLON data_type
                | ;

parameter ::= IDENTIFIER COLON data_type COMMA parameter| IDENTIFIER COLON data_type|;


data_type ::= seq
          | dict
          | INT
          | FLOAT
          | RAT
          | BOOL
          | CHAR
          | TOP ;//dict might be an issue

statements__ ::= break_statement
            | dictionary_binding
            | if_statement
            | if_else_statement
            | loop_statement
            | return_
            | typeDefinition
            | print_statement
            | alias
            | assignment
            | function_call SEMI
            | function
			| read_statement;

decla ::= declaration
	   | declaration_assignment;

statements_ ::= statements__ statements_ | statements__ ;

statements ::= decla | decla statements | statements_;
print_statement ::= PRINT expression SEMI;
read_statement ::= READ identifier SEMI;

expression ::= data  //an ambiguity can be assigning empty to a variable? what would happern?
		   | operation
		   | identifier
           | comparison
		   | dictionary
		   | sequence
		   | equality
		   | boolean_operations
		   | in
 		   | concat
           | function_call
           | MINUS expression
		   | LPAREN expression RPAREN;


identifier ::= IDENTIFIER | IDENTIFIER DOT identifier | IDENTIFIER LBRACKET expression RBRACKET | sequenceSlicing DOT identifier | sequenceSlicing;

data ::= NUMBER | CHARACTER | BOOLEAN | STRING;

declaration ::= IDENTIFIER COLON data_type dec | IDENTIFIER COLON IDENTIFIER dec;
dec::= SEMI |;  //we should add this to ambiguities that we can assign functions in declarations

declaration_assignment ::= declaration COLONEQ all_data SEMI;
all_data ::= expression | expression COMMA all_data;

assignment ::= identifier COLONEQ expression SEMI; //define data imo the data should be passed from the lexer
//s1:string := "Alice in Wonderland";
// dictionary_binding ::= IDENTIFIER LBRACKET expression RBRACKET COLON COLONEQ expression SEMI;
//l1:seq<string> := ["a","b", "c", "d", "e"];
dictionary ::= LCURL dict_element RCURL;
dict_element ::= data_type COLON data_type COMMA dict_element
   	     | ;

sequence ::=  LBRACKET seq_element RBRACKET; ///[2]
seq_element ::= expression COMMA seq_element | expression |;


typeDefinition ::= TDEF IDENTIFIER LCURL objectArray RCURL SEMI;

objectArray ::= IDENTIFIER COLON IDENTIFIER arr
             | IDENTIFIER COLON data_type arr;

arr ::= COMMA objectArray
    |
    ;

alias ::= ALIAS data_type IDENTIFIER SEMI
      | ALIAS IDENTIFIER IDENTIFIER SEMI ;

// // //function declaration
// // //fucntion use

function_call ::= QMARK expression QMARK IDENTIFIER LPAREN params RPAREN;

params_ ::= expression COMMA params_
       | expression;

params ::= params_ | ;

if_statement ::= IF LPAREN expression RPAREN THEN statements ELSE statements FI
             | IF LPAREN expression RPAREN THEN statements FI;

//if (i) then
break_statement ::= BREAK SEMI
                | BREAK NUMBER SEMI;   //the ambiguity here is that when break is outside the loop how would we realize

loop_statement ::= LOOP statements POOL;

/*comparison ::= NUMBER LT NUMBER
            | NUMBER LTEQ NUMBER;*/

comparison ::= expression LT expression
			| expression LTEQ expression ;


//if (i<books)

equality ::= expression EQ expression
          | expression NOTEQ expression;

// // //We need to think about this case bool a = 2

boolean_operations ::= NOT expression
            | expression AND expression
		        | expression OR expression
		        | expression IMPLY expression
		        ;


in ::= expression IN IDENTIFIER | expression IN dictionary | expression IN sequence;

sequenceSlicing ::= IDENTIFIER LBRACKET sequenceTail RBRACKET;
          /*data_type IN data_type*/
          /*| data_type COLON data_type ;*/


          ///thirdlist:seq<top> := l2[:-2] :: l2[3:];

 sequenceTail ::= expression COLON expression
             | expression COLON
             | COLON expression;

/*a.b.c.name[1:2].foo.bar.name[1]*/


concat ::= idiot COLONCOLON idiot
        | idiot COLONCOLON concat;
        /*| idiot COLONCOLON concat
        | idiot;*/
        /*| identifier COLONCOLON concat
        | identifier COLONCOLON identifier
        | identifier COLONCOLON identifier COLONCOLON concat
        | sequence  COLONCOLON sequence COLONCOLON concat
        | identifier COLONCOLON sequence  COLONCOLON concat
        | sequence COLONCOLON identifier COLONCOLON concat ;*/
idiot ::= sequence | identifier ;
        //anotherlist:seq<top> := [s1] :: [s2] :: newlist;

seq ::= SEQ LT data_type GT
     | SEQ LT IDENTIFIER GT;

main ::= MAIN LCURL statements RCURL SEMI;

return_ ::= RETURN SEMI
        | RETURN expression SEMI;


dict ::= DICT LT data_type COMMA data_type GT;

// //one of the amguities is + coming before negative numbers

operation  ::= expression PLUS expression
	      | expression MINUS expression
	      | expression TIMES expression
	      | expression DIV expression
	      | expression MOD expression
	      | expression POW expression;
