//Package and import declarations
import java_cup.runtime.*;




// //User code components (Linking with the lexer)

// parser code {:
//     // Connect this parser to a scanner!
//     scanner s;
//     Parser(scanner s){ this.s=s; }
// :}

// //  define how to connect to the scanner!
// init with {: s.init(); :};
// scan with {: return s.next_token(); :};

parser code  {:
  public boolean syntaxErrors = false;
  public void syntax_error(Symbol current_token) {
  	  syntaxErrors = true;
      report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null);
      }
:};



//Symbols (Terminal and non-terminal lists)

terminal SEMI, COLON, LPAREN, RPAREN, COMMA, LCURL, RCURL, LBRACKET, RBRACKET, NOT, COLONCOLON;
terminal CHARACTER, BOOL, DICT, SEQ, NUMBER, TOP, BOOLEAN, RAT, INT, FLOAT, CHAR;
terminal ALIAS, IF, FI, LOOP, POOL, TDEF, BREAK, FDEF, THEN, ELSE, IN;
terminal IDENTIFIER;
terminal PLUS,  MINUS, TIMES, DIV, MOD;
terminal COLONEQ, LT, GT, LTEQ, EQ, NOTEQ;
terminal AND, OR, IMPLY;
terminal RETURN, MAIN, READ, POW;
terminal QMARK;


///

non terminal statements, body, declaration, expression, declaration_assignment, dictionary_binding, typeDefinition, objectArray;
non terminal alias, parameter, parameterTail, function, returnType, if_statement, if_else_statement, break_statement;
non terminal loop_statement, comparison, equality, boolean_operations, sequence, sequenceTail, operation, concat, concat_tail;
non terminal dictionary, dict_element, seq_element, in, data, sequenceSlicing, data_type, return_, function_call, params;
non terminal main, initial, dec, arr, seq, assignment;


//Precedence declaration

precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD, POW;
precedence left NOT, AND, OR, IMPLY;



//Grammar (context-free)

//number ::= FLOAT | RAT | INT

start with initial;

initial ::= function
        |
        main
        |
        statements
        |
        expression
        ;



function ::= FDEF IDENTIFIER LPAREN parameter RPAREN LCURL statements RCURL returnType SEMI; ////do we need to consider space?

returnType ::= COLON data_type
		   |
		   ;

parameter ::= IDENTIFIER COLON data_type parameterTail;
parameterTail ::= COMMA parameter
			  |
			  ;


data_type ::= seq
          |
          DICT //this might be an issue
          |
          INT
          |
          FLOAT
          |
          RAT
          |
          BOOL
          |
          CHAR
          ;

statements ::= declaration statements | declaration_assignment statements | break_statement statements | dictionary_binding statements | if_statement statements | if_else_statement statements | loop_statement statements | return_ statements| typeDefinition statements | alias statements | assignment statements|;
///the body of the functions



expression ::= data expression //an ambiguity can be assigning empty to a variable? what would happern?
		   |
		   function_call
		   |
		   operation
		   |
		   comparison
		   |
		   dictionary
		   |
		   sequence
		   |
		   equality
		   |
		   boolean_operations
		   |
		   in
		   |
 		   sequenceSlicing
 		   |
 		   concat
 		   ;

data ::= NUMBER | CHARACTER | BOOLEAN;

// declaration ::= IDENTIFIER COLON data_type dec;
// dec::= SEMI
//    |
//    ;  //we should add this to ambiguities that we can assign functions in declarations

// declaration_assignment ::= declaration COLONEQ expression SEMI;
assignment ::= IDENTIFIER COLONEQ IDENTIFIER SEMI | IDENTIFIER COLONEQ expression SEMI; //define data imo the data should be passed from the lexer

// dictionary_binding ::= IDENTIFIER LBRACKET expression RBRACKET COLON COLONEQ expression SEMI;

// dictionary ::= LCURL dict_element RCURL;
// dict_element ::= data_type COLON data_type COMMA dict_element
// 			 |
// 			 ;

// sequence ::=  LBRACKET seq_element RBRACKET; ///[2]
// seq_element ::= data_type COMMA seq_element
// 			|
// 			;


typeDefinition ::= TDEF IDENTIFIER LCURL objectArray RCURL SEMI;
objectArray ::= IDENTIFIER COLON IDENTIFIER arr| IDENTIFIER COLON data_type arr;
arr ::= COMMA objectArray
    |
    ;




alias ::= ALIAS data_type IDENTIFIER SEMI 
      |
      ALIAS IDENTIFIER IDENTIFIER SEMI
      ;




// // //function declaration
// // //fucntion use

function_call ::= IDENTIFIER LPAREN params RPAREN SEMI;

params ::= expression COMMA params
       |
       expression
       |
       ;



if_statement ::= IF LPAREN expression RPAREN THEN statements ELSE statements FI | IF LPAREN expression RPAREN THEN statements FI;


break_statement ::= BREAK SEMI| BREAK NUMBER SEMI;   //the ambiguity here is that when break is outside the loop how would we realize

loop_statement ::= LOOP statements POOL;

comparison ::= NUMBER LT NUMBER | NUMBER LTEQ NUMBER;

equality ::= NUMBER EQ NUMBER | BOOL EQ BOOL| NUMBER NOTEQ NUMBER| BOOL NOTEQ BOOL;


// // //We need to think about this case bool a = 2
boolean_operations ::= NOT boolean_operations
		   		   |
		   		   boolean_operations AND boolean_operations
		           |
		           boolean_operations OR boolean_operations
		           |
		           boolean_operations IMPLY boolean_operations
		           |
		           BOOLEAN
		           ;


in ::= data_type IN sequence
   |
   data_type IN dictionary
   ;

// sequenceSlicing ::= IDENTIFIER LBRACKET sequenceTail RBRACKET
//          |
//          data_type IN data_type
//          |
//          data_type COLON data_type
//          ;

// sequenceTail ::= IDENTIFIER COLON IDENTIFIER
//              |
//              IDENTIFIER COLON
//              |
//              COLON IDENTIFIER
//              ;

// concat ::= SEQ COLONCOLON SEQ concat_tail
//        |
//        IDENTIFIER COLONCOLON IDENTIFIER concat_tail
//        ;

// concat_tail  ::= COLONCOLON SEQ concat_tail
//             |
//             COLONCOLON IDENTIFIER concat_tail
//             |
//             ;


seq ::= SEQ LT data_type GT| SEQ LT IDENTIFIER GT;

main ::= MAIN LCURL statements RCURL SEMI;

return_ ::= RETURN SEMI
        |
        RETURN expression SEMI
        ;

// //one of the amguities is + coming before negative numbers

// operation  ::= operation PLUS operation
// 	      |
// 	      operation MINUS operation
// 	      |
//           operation TIMES operation
// 	      |
// 	      operation DIV operation
// 	      |
//           operation MOD operation
// 	      |
// 	      operation POW operation
// 	      |
//        NUMBER
// 	      |
//        MINUS operation
// 	      |
//        LPAREN operation RPAREN
//        ;
