//Package and import declerations
import java_cup.runtime.*;




//User code components (Linking with the lexer)

// parser code {:
//     // Connect this parser to a scanner!
//     scanner s;
//     Parser(scanner s){ this.s=s; }
// :}

//  define how to connect to the scanner! 
// init with {: s.init(); :};
// scan with {: return s.next_token(); :};




//Symbols (Terminal and non-terminal lists)

terminal SEMI, COLON, LPAREN, RPAREN, PUNC, LCURL, RCURL, LBRACKET, RBRACKET, EXCLAM;
terminal CHARACTER, BOOL, DICT, SEQ, NUMBER, DATATYPE, TOP;
terminal ALIAS, IF, FI, LOOP, POOL, TDEF, BREAK, FDEF, THEN, ELSE, IN;
terminal IDENTIFIER;
terminal PLUS,  MINUS, TIMES, DIVIDE;
terminal ASSIGN_EQUAL, SMALLER, SMALLER_EQ, EQUAL, NOTEQUAL;
terminal AND, OR, IMPLY;


///

non terminal statements, body, declaration, expression, decleration_assignment, dictionary_binding, typeDefinition, objectArray;
non terminal alias, parameter, parameterTail, function, returnType, if_statement, if_else_statement, break_statement;
non terminal loop_statement, comparison, equality, boolean_operations, sequence, sequenceTail, operation;



//Precedence declaration

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;



//Grammar (context-free)

//number ::= FLOAT | RAT | INT

statements ::= declaration | decleration_assignment | break_statement  ///the body of the functions

body ::= body statements | 


declaration ::= IDENTIFIER COLON DATATYPE SEMI

expression ::= DATA | function | operation | comparison | IDENTIFIER       //we should add this to ambiguities that we can assign functions in declerations

decleration_assignment ::= declaration ASSIGN_EQUAL expression //define data imo the data should be passed from the lexer 

dictionary_binding ::= IDENTIFIER LBRACKET expression RBRACKET COLON ASSIGN_EQUAL expression
//d[k] := v


typeDefinition ::= TDEF IDENTIFIER LCURL objectArray RCURL SEMI
objectArray ::= IDENTIFIER COLON DATATYPE PUNC objectArray | IDENTIFIER COLON dataType SEMI


alias ::= ALIAS DATATYPE IDENTIFIER SEMI | ALIAS IDENTIFIER IDENTIFIER SEMI


parameter ::= DATATYPE IDENTIFIER parameterTail 

parameterTail ::= PUNC parameter | 


//function decleration
//fucntion use

function ::= FDEF IDENTIFIER LPAREN parameter RPAREN LCURL body RCURL returnType SEMI ////do we need to consider space?

returnType ::= COLON DATATYPE |


if_statement ::= IF LPAREN expression RPAREN THEN body if_else_statement FI

if_else_statement ::= ELSE body |


break_statement ::= BREAK | BREAK NUMBER   //the ambiguity here is that when break is outside the loop how would we realize
loop_statement ::= LOOP body POOL

comparison ::= NUMBER SMALLER NUMBER
 		   |
 		   NUMBER SMALLER_EQ NUMBER
 		   

equality ::= NUMBER EQUAL NUMBER
		 | BOOL EQUAL BOOL
		 | NUMBER NOTEQUAL NUMBER
		 | BOOL NOTEQUAL BOOL


//We need to think about this case bool a = 2
boolean_operations ::= EXCLAM expression 
		   		   | 
		   		   expression AND expression
		           | 
		           expression OR expression
		           | 
		           expression IMPLY expression

//in, ::, s[i],
sequence ::= IDENTIFIER LBRACKET sequenceTail RBRACKET | DATATYPE IN DATATYPE | DATATYPE COLON DATATYPE  

sequenceTail ::= IDENTIFIER COLON IDENTIFIER | IDENTIFIER COLON | COLON IDENTIFIER 


//one of the amguities is + coming before negative numbers

operation  ::= operation PLUS operation   
	      |
	      operation MINUS operation   
	      | 
          operation TIMES operation 
	      | 
	      operation DIVIDE operation 
	      | 
          operation MOD operation 
	      | 
          NUMBER                  
	      | 
          MINUS operation             
	      | 
          LPAREN operation RPAREN     



